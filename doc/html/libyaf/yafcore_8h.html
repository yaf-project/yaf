<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--
    Copyright (C) 2006-2025 Carnegie Mellon University
    See license information in LICENSE.txt.
-->
<!--
    @DISTRIBUTION_STATEMENT_BEGIN@
    YAF 2.16
    Copyright 2024 Carnegie Mellon University.
    NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
    INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
    UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
    AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR
    PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF
    THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF
    ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
    INFRINGEMENT.
    Licensed under a GNU GPL 2.0-style license, please see LICENSE.txt or
    contact permission@sei.cmu.edu for full terms.
    [DISTRIBUTION STATEMENT A] This material has been approved for public
    release and unlimited distribution.  Please see Copyright notice for
    non-US Government use and distribution.
    This Software includes and/or makes use of Third-Party Software each
    subject to its own license.
    DM24-1063
    @DISTRIBUTION_STATEMENT_END@
-->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAF: yafcore.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Tutorials</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8eeec8564a1d5c9e61fe9a86a06f2592.html">yaf-2.16.4</a></li><li class="navelem"><a class="el" href="dir_24ba5edbaa71b1336028a35d7c80cfec.html">include</a></li><li class="navelem"><a class="el" href="dir_55762c24e7cf9c8609bb688e219816e9.html">yaf</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">yafcore.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;yaf/autoinc.h&gt;</code><br />
<code>#include &lt;fixbuf/public.h&gt;</code><br />
<code>#include &lt;yaf/yaftime.h&gt;</code><br />
</div>
<p><a href="yafcore_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow_key__st.html">yfFlowKey_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow key.  <a href="structyf_flow_key__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow_stats__st.html">yfFlowStats_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">yaf enhanced flow statistics  <a href="structyf_flow_stats__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow_val__st.html">yfFlowVal_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF uniflow value.  <a href="structyf_flow_val__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaf__mptcp__st.html">yaf_mptcp_st</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow__st.html">yfFlow_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow.  <a href="structyf_flow__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4e870a7230abc740fa814dda775d8c6e" id="r_a4e870a7230abc740fa814dda775d8c6e"><td class="memItemLeft" align="right" valign="top"><a id="a4e870a7230abc740fa814dda775d8c6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CERT_PEN</b>&#160;&#160;&#160;6871</td></tr>
<tr class="memdesc:a4e870a7230abc740fa814dda775d8c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the CERT Private Enterprise Number (PEN) assigned by IANA, used to define our enterprise data elements to extend IPFIX RFC 5103 data model. <br /></td></tr>
<tr class="separator:a4e870a7230abc740fa814dda775d8c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf8a39a94f6927eccf237b681308d7" id="r_a90bf8a39a94f6927eccf237b681308d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90bf8a39a94f6927eccf237b681308d7">YAF_ERROR_DOMAIN</a>&#160;&#160;&#160;(g_quark_from_string(&quot;certYAFError&quot;))</td></tr>
<tr class="memdesc:a90bf8a39a94f6927eccf237b681308d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GError domain for YAF errors.  <br /></td></tr>
<tr class="separator:a90bf8a39a94f6927eccf237b681308d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5a2f530d778e1f7f1f4973a278a2f6" id="r_aca5a2f530d778e1f7f1f4973a278a2f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca5a2f530d778e1f7f1f4973a278a2f6">YAF_ERROR_HEADER</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aca5a2f530d778e1f7f1f4973a278a2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF file header was malformed.  <br /></td></tr>
<tr class="separator:aca5a2f530d778e1f7f1f4973a278a2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6282c576b6fc85c037ec4ea6944f8c58" id="r_a6282c576b6fc85c037ec4ea6944f8c58"><td class="memItemLeft" align="right" valign="top"><a id="a6282c576b6fc85c037ec4ea6944f8c58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_ARGUMENT</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a6282c576b6fc85c037ec4ea6944f8c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Illegal argument error. <br /></td></tr>
<tr class="separator:a6282c576b6fc85c037ec4ea6944f8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676a9aa996fbb642eabbe13196f1dd91" id="r_a676a9aa996fbb642eabbe13196f1dd91"><td class="memItemLeft" align="right" valign="top"><a id="a676a9aa996fbb642eabbe13196f1dd91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_IO</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a676a9aa996fbb642eabbe13196f1dd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">General I/O error. <br /></td></tr>
<tr class="separator:a676a9aa996fbb642eabbe13196f1dd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671b4e1cc3bca4f38a5d55cbec210528" id="r_a671b4e1cc3bca4f38a5d55cbec210528"><td class="memItemLeft" align="right" valign="top"><a id="a671b4e1cc3bca4f38a5d55cbec210528"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_IPFIX</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a671b4e1cc3bca4f38a5d55cbec210528"><td class="mdescLeft">&#160;</td><td class="mdescRight">YAF could not accept IPFIX input due to missing fields. <br /></td></tr>
<tr class="separator:a671b4e1cc3bca4f38a5d55cbec210528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc8dc3f90ea1cdd17e7d9087f0a9193" id="r_adbc8dc3f90ea1cdd17e7d9087f0a9193"><td class="memItemLeft" align="right" valign="top"><a id="adbc8dc3f90ea1cdd17e7d9087f0a9193"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_IMPL</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:adbc8dc3f90ea1cdd17e7d9087f0a9193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested feature is not available. <br /></td></tr>
<tr class="separator:adbc8dc3f90ea1cdd17e7d9087f0a9193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e744837dbf0dafb0b3a81a482c4b4b" id="r_a73e744837dbf0dafb0b3a81a482c4b4b"><td class="memItemLeft" align="right" valign="top"><a id="a73e744837dbf0dafb0b3a81a482c4b4b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_INTERNAL</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a73e744837dbf0dafb0b3a81a482c4b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal error occured (aka a bug) <br /></td></tr>
<tr class="separator:a73e744837dbf0dafb0b3a81a482c4b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d90d371e4eadbd2372964d75db45553" id="r_a9d90d371e4eadbd2372964d75db45553"><td class="memItemLeft" align="right" valign="top"><a id="a9d90d371e4eadbd2372964d75db45553"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_LIMIT</b>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a9d90d371e4eadbd2372964d75db45553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard program limit reached. <br /></td></tr>
<tr class="separator:a9d90d371e4eadbd2372964d75db45553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518d378ce28866a23bbeb14b247f3441" id="r_a518d378ce28866a23bbeb14b247f3441"><td class="memItemLeft" align="right" valign="top"><a id="a518d378ce28866a23bbeb14b247f3441"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_EOF</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a518d378ce28866a23bbeb14b247f3441"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of file. <br /></td></tr>
<tr class="separator:a518d378ce28866a23bbeb14b247f3441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2225e5d104fbced4de6fdf219f1d795b" id="r_a2225e5d104fbced4de6fdf219f1d795b"><td class="memItemLeft" align="right" valign="top"><a id="a2225e5d104fbced4de6fdf219f1d795b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_ALIGNMENT</b>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a2225e5d104fbced4de6fdf219f1d795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal alignment error. <br /></td></tr>
<tr class="separator:a2225e5d104fbced4de6fdf219f1d795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f63276eb8f1e2e1ebfd2dd20cf2abb" id="r_ae9f63276eb8f1e2e1ebfd2dd20cf2abb"><td class="memItemLeft" align="right" valign="top"><a id="ae9f63276eb8f1e2e1ebfd2dd20cf2abb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_PACKET_PAYLOAD</b>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ae9f63276eb8f1e2e1ebfd2dd20cf2abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet payload processing error. <br /></td></tr>
<tr class="separator:ae9f63276eb8f1e2e1ebfd2dd20cf2abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748ec2ae26f407ac851800cdd787a552" id="r_a748ec2ae26f407ac851800cdd787a552"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a748ec2ae26f407ac851800cdd787a552">YAF_FLOW_ACTIVE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a748ec2ae26f407ac851800cdd787a552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo end reason for flows still active during collection.  <br /></td></tr>
<tr class="separator:a748ec2ae26f407ac851800cdd787a552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1f8e4daf657da7126bd7986182ec25" id="r_a2e1f8e4daf657da7126bd7986182ec25"><td class="memItemLeft" align="right" valign="top"><a id="a2e1f8e4daf657da7126bd7986182ec25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_IDLE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a2e1f8e4daf657da7126bd7986182ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to idle timeout. <br /></td></tr>
<tr class="separator:a2e1f8e4daf657da7126bd7986182ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594540d5d2cdf742926790b59d18b1a" id="r_a7594540d5d2cdf742926790b59d18b1a"><td class="memItemLeft" align="right" valign="top"><a id="a7594540d5d2cdf742926790b59d18b1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_ACTIVE</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a7594540d5d2cdf742926790b59d18b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to active timeout. <br /></td></tr>
<tr class="separator:a7594540d5d2cdf742926790b59d18b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a00d70c7f0428edc3d7b1052cc1874c" id="r_a8a00d70c7f0428edc3d7b1052cc1874c"><td class="memItemLeft" align="right" valign="top"><a id="a8a00d70c7f0428edc3d7b1052cc1874c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_CLOSED</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a8a00d70c7f0428edc3d7b1052cc1874c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to FIN or RST close. <br /></td></tr>
<tr class="separator:a8a00d70c7f0428edc3d7b1052cc1874c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ad71ab8c519b50a668b5355d1fa49" id="r_adc3ad71ab8c519b50a668b5355d1fa49"><td class="memItemLeft" align="right" valign="top"><a id="adc3ad71ab8c519b50a668b5355d1fa49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_FORCED</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:adc3ad71ab8c519b50a668b5355d1fa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to YAF shutdown. <br /></td></tr>
<tr class="separator:adc3ad71ab8c519b50a668b5355d1fa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd7519c1766797ccb4a4de0db11860b" id="r_a7dd7519c1766797ccb4a4de0db11860b"><td class="memItemLeft" align="right" valign="top"><a id="a7dd7519c1766797ccb4a4de0db11860b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_RESOURCE</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a7dd7519c1766797ccb4a4de0db11860b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow flushed due to YAF resource exhaustion. <br /></td></tr>
<tr class="separator:a7dd7519c1766797ccb4a4de0db11860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416127276f04d95e28b15f018ae9196d" id="r_a416127276f04d95e28b15f018ae9196d"><td class="memItemLeft" align="right" valign="top"><a id="a416127276f04d95e28b15f018ae9196d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_UDPFORCE</b>&#160;&#160;&#160;0x1F</td></tr>
<tr class="memdesc:a416127276f04d95e28b15f018ae9196d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow flushed due to udp-uniflow on all or selected ports. <br /></td></tr>
<tr class="separator:a416127276f04d95e28b15f018ae9196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a3726fe7960f4bea91466c930904ea" id="r_ab0a3726fe7960f4bea91466c930904ea"><td class="memItemLeft" align="right" valign="top"><a id="ab0a3726fe7960f4bea91466c930904ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_MASK</b>&#160;&#160;&#160;0x7F</td></tr>
<tr class="memdesc:ab0a3726fe7960f4bea91466c930904ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow reason mask. <br /></td></tr>
<tr class="separator:ab0a3726fe7960f4bea91466c930904ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae912d9a7f9cf3ff896f5ba9e849f1e66" id="r_ae912d9a7f9cf3ff896f5ba9e849f1e66"><td class="memItemLeft" align="right" valign="top"><a id="ae912d9a7f9cf3ff896f5ba9e849f1e66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ENDF_ISCONT</b>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:ae912d9a7f9cf3ff896f5ba9e849f1e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">SiLK mode flow reason flag - flow was created after active termination. <br /></td></tr>
<tr class="separator:ae912d9a7f9cf3ff896f5ba9e849f1e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af797d04660c7f352b5c6fe8faf325fe6" id="r_af797d04660c7f352b5c6fe8faf325fe6"><td class="memItemLeft" align="right" valign="top"><a id="af797d04660c7f352b5c6fe8faf325fe6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_SAME_SIZE</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:af797d04660c7f352b5c6fe8faf325fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute bit flag: Flow has same size packets in this direction. <br /></td></tr>
<tr class="separator:af797d04660c7f352b5c6fe8faf325fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0924e9fd97124c7f992e8bda2ac3df0" id="r_ad0924e9fd97124c7f992e8bda2ac3df0"><td class="memItemLeft" align="right" valign="top"><a id="ad0924e9fd97124c7f992e8bda2ac3df0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_OUT_OF_SEQUENCE</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ad0924e9fd97124c7f992e8bda2ac3df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute bit flag: Flow was processed out of sequence. <br /></td></tr>
<tr class="separator:ad0924e9fd97124c7f992e8bda2ac3df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d1729bca8e7d4651160e3579e67c5b" id="r_ab2d1729bca8e7d4651160e3579e67c5b"><td class="memItemLeft" align="right" valign="top"><a id="ab2d1729bca8e7d4651160e3579e67c5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MP_CAPABLE</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:ab2d1729bca8e7d4651160e3579e67c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute bit flag: Flow had MP_CAPABLE TCP Option. <br /></td></tr>
<tr class="separator:ab2d1729bca8e7d4651160e3579e67c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2851172808f819b461721c4952a5de" id="r_a0d2851172808f819b461721c4952a5de"><td class="memItemLeft" align="right" valign="top"><a id="a0d2851172808f819b461721c4952a5de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_FRAGMENTS</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:a0d2851172808f819b461721c4952a5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute bit flag: Flow contained packets that were fragmented. <br /></td></tr>
<tr class="separator:a0d2851172808f819b461721c4952a5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219601cfc9f6ab1c38648afafbb596c9" id="r_a219601cfc9f6ab1c38648afafbb596c9"><td class="memItemLeft" align="right" valign="top"><a id="a219601cfc9f6ab1c38648afafbb596c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_PARTIAL_FRAGS</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a219601cfc9f6ab1c38648afafbb596c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow contains partial fragments. <br /></td></tr>
<tr class="separator:a219601cfc9f6ab1c38648afafbb596c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741d946a09ea41f01d32f1bb770d0003" id="r_a741d946a09ea41f01d32f1bb770d0003"><td class="memItemLeft" align="right" valign="top"><a id="a741d946a09ea41f01d32f1bb770d0003"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_FRAG_ACTIVE</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:a741d946a09ea41f01d32f1bb770d0003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow has fragments that have reached active timeout. <br /></td></tr>
<tr class="separator:a741d946a09ea41f01d32f1bb770d0003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4305f7e14741c460ec98b000e6d96815" id="r_a4305f7e14741c460ec98b000e6d96815"><td class="memItemLeft" align="right" valign="top"><a id="a4305f7e14741c460ec98b000e6d96815"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_FRAG_PASSIVE</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:a4305f7e14741c460ec98b000e6d96815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow has fragments that have reached passive timeout. <br /></td></tr>
<tr class="separator:a4305f7e14741c460ec98b000e6d96815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb7c588d476dd7dacff04b6f2b87fd8" id="r_a1fb7c588d476dd7dacff04b6f2b87fd8"><td class="memItemLeft" align="right" valign="top"><a id="a1fb7c588d476dd7dacff04b6f2b87fd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_IP_ICMP</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a1fb7c588d476dd7dacff04b6f2b87fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocol identifier for ICMP. <br /></td></tr>
<tr class="separator:a1fb7c588d476dd7dacff04b6f2b87fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddac667f4893f825b2c36f439cf2d25" id="r_a6ddac667f4893f825b2c36f439cf2d25"><td class="memItemLeft" align="right" valign="top"><a id="a6ddac667f4893f825b2c36f439cf2d25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_IP_TCP</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a6ddac667f4893f825b2c36f439cf2d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocol identifier for TCP. <br /></td></tr>
<tr class="separator:a6ddac667f4893f825b2c36f439cf2d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfb66639fbd610af657911ed5de5a06" id="r_a1bfb66639fbd610af657911ed5de5a06"><td class="memItemLeft" align="right" valign="top"><a id="a1bfb66639fbd610af657911ed5de5a06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_IP_UDP</b>&#160;&#160;&#160;17</td></tr>
<tr class="memdesc:a1bfb66639fbd610af657911ed5de5a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocol identifier for UDP. <br /></td></tr>
<tr class="separator:a1bfb66639fbd610af657911ed5de5a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c00594ac34eb99ead87136ff390093" id="r_a44c00594ac34eb99ead87136ff390093"><td class="memItemLeft" align="right" valign="top"><a id="a44c00594ac34eb99ead87136ff390093"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YFP_IPTCPHEADER_SIZE</b>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:a44c00594ac34eb99ead87136ff390093"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the size of the packet to store away for use primarily in passive OS fingerprinting, this value is only used if application labeling is enabled. <br /></td></tr>
<tr class="separator:a44c00594ac34eb99ead87136ff390093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcda5832463d24a4f46a5e646121892" id="r_a9dcda5832463d24a4f46a5e646121892"><td class="memItemLeft" align="right" valign="top"><a id="a9dcda5832463d24a4f46a5e646121892"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ETHERNET_MAC_ADDR_LENGTH</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a9dcda5832463d24a4f46a5e646121892"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of Ethernet MAC Address <br /></td></tr>
<tr class="separator:a9dcda5832463d24a4f46a5e646121892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2395ccdd70f26be0ecef94cca543efda" id="r_a2395ccdd70f26be0ecef94cca543efda"><td class="memItemLeft" align="right" valign="top"><a id="a2395ccdd70f26be0ecef94cca543efda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MAX_HOOKS</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a2395ccdd70f26be0ecef94cca543efda"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of hooks (plugins) allowed at one time <br /></td></tr>
<tr class="separator:a2395ccdd70f26be0ecef94cca543efda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02f9275b48945fbb8ef55058be71f6c" id="r_aa02f9275b48945fbb8ef55058be71f6c"><td class="memItemLeft" align="right" valign="top"><a id="aa02f9275b48945fbb8ef55058be71f6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_HOOKS_MAX_EXPORT</b>&#160;&#160;&#160;1500</td></tr>
<tr class="memdesc:aa02f9275b48945fbb8ef55058be71f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the maximum amount of data that the plugins may export in sum total <br /></td></tr>
<tr class="separator:aa02f9275b48945fbb8ef55058be71f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a096b81cc71a4436967322b1dea4994" id="r_a9a096b81cc71a4436967322b1dea4994"><td class="memItemLeft" align="right" valign="top"><a id="a9a096b81cc71a4436967322b1dea4994"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MAX_PKT_BOUNDARY</b>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:a9a096b81cc71a4436967322b1dea4994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Number of Packet Boundaries to keep around per payload. <br /></td></tr>
<tr class="separator:a9a096b81cc71a4436967322b1dea4994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d6a419db9b3f4d638d664a5c897691" id="r_a93d6a419db9b3f4d638d664a5c897691"><td class="memItemLeft" align="right" valign="top"><a id="a93d6a419db9b3f4d638d664a5c897691"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_PCAP_MAX</b>&#160;&#160;&#160;5000000</td></tr>
<tr class="memdesc:a93d6a419db9b3f4d638d664a5c897691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of PCAP output file - 5MB. <br /></td></tr>
<tr class="separator:a93d6a419db9b3f4d638d664a5c897691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc0f654dac7b347d8a50b446397faf7" id="r_a0dc0f654dac7b347d8a50b446397faf7"><td class="memItemLeft" align="right" valign="top"><a id="a0dc0f654dac7b347d8a50b446397faf7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MAX_MPLS_LABELS</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a0dc0f654dac7b347d8a50b446397faf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of labels we're going to keep around. <br /></td></tr>
<tr class="separator:a0dc0f654dac7b347d8a50b446397faf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad935c8182e21f98f6ea867f09a2ffac1" id="r_ad935c8182e21f98f6ea867f09a2ffac1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad935c8182e21f98f6ea867f09a2ffac1">YAF_SMALL_PKT_BOUND</a>&#160;&#160;&#160;60</td></tr>
<tr class="memdesc:ad935c8182e21f98f6ea867f09a2ffac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper bound of a packet's payload octets to be a "small packet" in the detailed flow-stats.  <br /></td></tr>
<tr class="separator:ad935c8182e21f98f6ea867f09a2ffac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36347f7131aec21a8017ef32a61454c6" id="r_a36347f7131aec21a8017ef32a61454c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36347f7131aec21a8017ef32a61454c6">YAF_LARGE_PKT_BOUND</a>&#160;&#160;&#160;225</td></tr>
<tr class="memdesc:a36347f7131aec21a8017ef32a61454c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower bound of a packet's payload octets to be a "large packet" in the detailed flow-stats.  <br /></td></tr>
<tr class="separator:a36347f7131aec21a8017ef32a61454c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528a0dc11320f67612f7cef00d73b128" id="r_a528a0dc11320f67612f7cef00d73b128"><td class="memItemLeft" align="right" valign="top"><a id="a528a0dc11320f67612f7cef00d73b128"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YF_TIME_IE__FIRST</b>&#160;&#160;&#160;<a class="el" href="#a68e5082889de2a82f6696c2b62842f07aa5c8299e6b5f68ac36dcb280e2ec4402">YF_TIME_IE_MILLI</a></td></tr>
<tr class="memdesc:a528a0dc11320f67612f7cef00d73b128"><td class="mdescLeft">&#160;</td><td class="mdescRight">First valid yfRecordTimeIE_t value. <br /></td></tr>
<tr class="separator:a528a0dc11320f67612f7cef00d73b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f858f1ff75199f66e5751d3155ea76c" id="r_a1f858f1ff75199f66e5751d3155ea76c"><td class="memItemLeft" align="right" valign="top"><a id="a1f858f1ff75199f66e5751d3155ea76c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YF_TIME_IE__LAST</b>&#160;&#160;&#160;<a class="el" href="#a68e5082889de2a82f6696c2b62842f07a3b3e785e296772ae50f44bc230ac0d4d">YF_TIME_IE_NANO</a></td></tr>
<tr class="memdesc:a1f858f1ff75199f66e5751d3155ea76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last valid yfRecordTimeIE_t value. <br /></td></tr>
<tr class="separator:a1f858f1ff75199f66e5751d3155ea76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89bfea8c9f01bbdf2febc3203550637" id="r_af89bfea8c9f01bbdf2febc3203550637"><td class="memItemLeft" align="right" valign="top"><a id="af89bfea8c9f01bbdf2febc3203550637"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YF_TIME_IE__DEFAULT</b>&#160;&#160;&#160;(<a class="el" href="#a68e5082889de2a82f6696c2b62842f07aa5c8299e6b5f68ac36dcb280e2ec4402">YF_TIME_IE_MILLI</a> | <a class="el" href="#a68e5082889de2a82f6696c2b62842f07a68ed164cc0bb7d8a3d0b7aa1b6aae928">YF_TIME_IE_MICRO</a>)</td></tr>
<tr class="memdesc:af89bfea8c9f01bbdf2febc3203550637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default yfRecordTimeIE_t to use. <br /></td></tr>
<tr class="separator:af89bfea8c9f01bbdf2febc3203550637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eee41e7090844cb7f516573fb65c065" id="r_a6eee41e7090844cb7f516573fb65c065"><td class="memItemLeft" align="right" valign="top"><a id="a6eee41e7090844cb7f516573fb65c065"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>yfRecordTimeIEBitSet</b>(t_)&#160;&#160;&#160;(1 &lt;&lt; ((t_) - 1))</td></tr>
<tr class="memdesc:a6eee41e7090844cb7f516573fb65c065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a yfRecordTimeIE_t to a value for adding to a bitfield. <br /></td></tr>
<tr class="separator:a6eee41e7090844cb7f516573fb65c065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e5f4e0758b780960323d18d431b332" id="r_a71e5f4e0758b780960323d18d431b332"><td class="memItemLeft" align="right" valign="top"><a id="a71e5f4e0758b780960323d18d431b332"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>yfRecordTimeIEBitCheck</b>(bits_,  t_)&#160;&#160;&#160;((bits_) &amp; <a class="el" href="#a6eee41e7090844cb7f516573fb65c065">yfRecordTimeIEBitSet</a>(t_))</td></tr>
<tr class="memdesc:a71e5f4e0758b780960323d18d431b332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the bitfield <code>bits_</code> contains the yfRecordTimeIE_t <code>t_</code> <br /></td></tr>
<tr class="separator:a71e5f4e0758b780960323d18d431b332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a30f599742a1993bfa79934307e0c26e1" id="r_a30f599742a1993bfa79934307e0c26e1"><td class="memItemLeft" align="right" valign="top"><a id="a30f599742a1993bfa79934307e0c26e1"></a>
typedef struct yfConfig_st&#160;</td><td class="memItemRight" valign="bottom"><b>yfConfig_t</b></td></tr>
<tr class="memdesc:a30f599742a1993bfa79934307e0c26e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">YAF Configuration Settings. <br /></td></tr>
<tr class="separator:a30f599742a1993bfa79934307e0c26e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe79660758c41b5f148715f242a166e" id="r_a1fe79660758c41b5f148715f242a166e"><td class="memItemLeft" align="right" valign="top"><a id="a1fe79660758c41b5f148715f242a166e"></a>
typedef enum <a class="el" href="#a68e5082889de2a82f6696c2b62842f07">yfRecordTimeIE_en</a>&#160;</td><td class="memItemRight" valign="bottom"><b>yfRecordTimeIE_t</b></td></tr>
<tr class="memdesc:a1fe79660758c41b5f148715f242a166e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to specify which timestamps are included. <br /></td></tr>
<tr class="separator:a1fe79660758c41b5f148715f242a166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac4b4f6b2720c2af3c728aec9abd7a2" id="r_a1ac4b4f6b2720c2af3c728aec9abd7a2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structyf_flow_key__st.html">yfFlowKey_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ac4b4f6b2720c2af3c728aec9abd7a2">yfFlowKey_t</a></td></tr>
<tr class="memdesc:a1ac4b4f6b2720c2af3c728aec9abd7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow key.  <br /></td></tr>
<tr class="separator:a1ac4b4f6b2720c2af3c728aec9abd7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d57343f0a558146a78d44e621bb5fa" id="r_ae3d57343f0a558146a78d44e621bb5fa"><td class="memItemLeft" align="right" valign="top"><a id="ae3d57343f0a558146a78d44e621bb5fa"></a>
typedef struct <a class="el" href="structyf_flow_stats__st.html">yfFlowStats_st</a>&#160;</td><td class="memItemRight" valign="bottom"><b>yfFlowStats_t</b></td></tr>
<tr class="memdesc:ae3d57343f0a558146a78d44e621bb5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">yaf enhanced flow statistics <br /></td></tr>
<tr class="separator:ae3d57343f0a558146a78d44e621bb5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c408b16b38eab11ab595368798ac304" id="r_a9c408b16b38eab11ab595368798ac304"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structyf_flow_val__st.html">yfFlowVal_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c408b16b38eab11ab595368798ac304">yfFlowVal_t</a></td></tr>
<tr class="memdesc:a9c408b16b38eab11ab595368798ac304"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF uniflow value.  <br /></td></tr>
<tr class="separator:a9c408b16b38eab11ab595368798ac304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7888bdf8eb7ce2ba167985c12df08c96" id="r_a7888bdf8eb7ce2ba167985c12df08c96"><td class="memItemLeft" align="right" valign="top"><a id="a7888bdf8eb7ce2ba167985c12df08c96"></a>
typedef struct <a class="el" href="structyaf__mptcp__st.html">yaf_mptcp_st</a>&#160;</td><td class="memItemRight" valign="bottom"><b>yaf_mptcp_t</b></td></tr>
<tr class="separator:a7888bdf8eb7ce2ba167985c12df08c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846c7e494485aceab2fcdec4264f90f" id="r_ac846c7e494485aceab2fcdec4264f90f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structyf_flow__st.html">yfFlow_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a></td></tr>
<tr class="memdesc:ac846c7e494485aceab2fcdec4264f90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow.  <br /></td></tr>
<tr class="separator:ac846c7e494485aceab2fcdec4264f90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a68e5082889de2a82f6696c2b62842f07" id="r_a68e5082889de2a82f6696c2b62842f07"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e5082889de2a82f6696c2b62842f07">yfRecordTimeIE_en</a> { <a class="el" href="#a68e5082889de2a82f6696c2b62842f07aa645f9b1a6baa00352a39c7ddb4e98af">YF_TIME_IE__UNSET</a>
, <a class="el" href="#a68e5082889de2a82f6696c2b62842f07aa5c8299e6b5f68ac36dcb280e2ec4402">YF_TIME_IE_MILLI</a>
, <a class="el" href="#a68e5082889de2a82f6696c2b62842f07a68ed164cc0bb7d8a3d0b7aa1b6aae928">YF_TIME_IE_MICRO</a>
, <a class="el" href="#a68e5082889de2a82f6696c2b62842f07a3b3e785e296772ae50f44bc230ac0d4d">YF_TIME_IE_NANO</a>
 }</td></tr>
<tr class="memdesc:a68e5082889de2a82f6696c2b62842f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to specify which timestamps are included.  <a href="#a68e5082889de2a82f6696c2b62842f07">More...</a><br /></td></tr>
<tr class="separator:a68e5082889de2a82f6696c2b62842f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68a8f1cdca0c20efb8bce1dd0e6917c1" id="r_a68a8f1cdca0c20efb8bce1dd0e6917c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a8f1cdca0c20efb8bce1dd0e6917c1">yfAlignmentCheck</a> (void)</td></tr>
<tr class="memdesc:a68a8f1cdca0c20efb8bce1dd0e6917c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">yfAlignmentCheck  <br /></td></tr>
<tr class="separator:a68a8f1cdca0c20efb8bce1dd0e6917c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a23294d877e529cacc564bb3a51488" id="r_a96a23294d877e529cacc564bb3a51488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a23294d877e529cacc564bb3a51488">yfFlowPrepare</a> (<a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow)</td></tr>
<tr class="memdesc:a96a23294d877e529cacc564bb3a51488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a static flow buffer for use with yaf_flow_read().  <br /></td></tr>
<tr class="separator:a96a23294d877e529cacc564bb3a51488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771c185221c27f7b69374c40b208a0e3" id="r_a771c185221c27f7b69374c40b208a0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a771c185221c27f7b69374c40b208a0e3">yfFlowCleanup</a> (<a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow)</td></tr>
<tr class="memdesc:a771c185221c27f7b69374c40b208a0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after a static flow buffer prepared by yfFlowPrepare.  <br /></td></tr>
<tr class="separator:a771c185221c27f7b69374c40b208a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aba3cec2881f1779b63d0586cb1daf" id="r_a73aba3cec2881f1779b63d0586cb1daf"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73aba3cec2881f1779b63d0586cb1daf">yfWriterForFile</a> (const char *path, const <a class="el" href="#a30f599742a1993bfa79934307e0c26e1">yfConfig_t</a> *yfConfig, GError **err)</td></tr>
<tr class="memdesc:a73aba3cec2881f1779b63d0586cb1daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for writing YAF flows to a named file.  <br /></td></tr>
<tr class="separator:a73aba3cec2881f1779b63d0586cb1daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb316c0a5e8ea19331de902e7e7117c" id="r_a7bb316c0a5e8ea19331de902e7e7117c"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb316c0a5e8ea19331de902e7e7117c">yfWriterForFP</a> (FILE *fp, const <a class="el" href="#a30f599742a1993bfa79934307e0c26e1">yfConfig_t</a> *yfConfig, GError **err)</td></tr>
<tr class="memdesc:a7bb316c0a5e8ea19331de902e7e7117c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for writing YAF flows to an open file pointer.  <br /></td></tr>
<tr class="separator:a7bb316c0a5e8ea19331de902e7e7117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07801f2dd9e1f54315b2f817e0eb3fd4" id="r_a07801f2dd9e1f54315b2f817e0eb3fd4"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07801f2dd9e1f54315b2f817e0eb3fd4">yfWriterForSpec</a> (fbConnSpec_t *spec, const <a class="el" href="#a30f599742a1993bfa79934307e0c26e1">yfConfig_t</a> *yfConfig, GError **err)</td></tr>
<tr class="memdesc:a07801f2dd9e1f54315b2f817e0eb3fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for writing YAF flows to a socket.  <br /></td></tr>
<tr class="separator:a07801f2dd9e1f54315b2f817e0eb3fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107643892b9846c39b27ecea4b90cf35" id="r_a107643892b9846c39b27ecea4b90cf35"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a107643892b9846c39b27ecea4b90cf35">yfWriteOptionsDataFlows</a> (void *yfContext, uint32_t pcap_drop, GTimer *timer, GError **err)</td></tr>
<tr class="memdesc:a107643892b9846c39b27ecea4b90cf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper that calls both yfWriteStatsFlow and yfWriteDataFlow with appropriate condition checking.  <br /></td></tr>
<tr class="separator:a107643892b9846c39b27ecea4b90cf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad688e7ab8e1c8a7c221db81b8b4ab9b" id="r_aad688e7ab8e1c8a7c221db81b8b4ab9b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad688e7ab8e1c8a7c221db81b8b4ab9b">yfWriteStatsFlow</a> (void *yfContext, uint32_t pcap_drop, GTimer *timer, GError **err)</td></tr>
<tr class="memdesc:aad688e7ab8e1c8a7c221db81b8b4ab9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a statistics options data record to an IPFIX Message buffer.  <br /></td></tr>
<tr class="separator:aad688e7ab8e1c8a7c221db81b8b4ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791a57ef2c8c5e66afa9ca3b9ceaa298" id="r_a791a57ef2c8c5e66afa9ca3b9ceaa298"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791a57ef2c8c5e66afa9ca3b9ceaa298">yfWriteTombstoneFlow</a> (void *yfContext, GError **err)</td></tr>
<tr class="memdesc:a791a57ef2c8c5e66afa9ca3b9ceaa298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a tombstone options data record to an IPFIX Message buffer.  <br /></td></tr>
<tr class="separator:a791a57ef2c8c5e66afa9ca3b9ceaa298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba445d9e6561395ee1a2de5a91ac15" id="r_a4aba445d9e6561395ee1a2de5a91ac15"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aba445d9e6561395ee1a2de5a91ac15">yfWriteFlow</a> (void *yfContext, <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a4aba445d9e6561395ee1a2de5a91ac15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single flow to an IPFIX message buffer.  <br /></td></tr>
<tr class="separator:a4aba445d9e6561395ee1a2de5a91ac15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d2497ad9dfacc3abb8cc20a95492b" id="r_ace9d2497ad9dfacc3abb8cc20a95492b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9d2497ad9dfacc3abb8cc20a95492b">yfWriterClose</a> (fBuf_t *fbuf, gboolean flush, GError **err)</td></tr>
<tr class="memdesc:ace9d2497ad9dfacc3abb8cc20a95492b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection underlying an IPFIX message buffer created by <a class="el" href="#a7bb316c0a5e8ea19331de902e7e7117c" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="#a07801f2dd9e1f54315b2f817e0eb3fd4" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a>.  <br /></td></tr>
<tr class="separator:ace9d2497ad9dfacc3abb8cc20a95492b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16f93ae5f4e71b3a5928feb2ca5e32e" id="r_ab16f93ae5f4e71b3a5928feb2ca5e32e"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab16f93ae5f4e71b3a5928feb2ca5e32e">yfReaderForFP</a> (fBuf_t *fbuf, FILE *fp, GError **err)</td></tr>
<tr class="memdesc:ab16f93ae5f4e71b3a5928feb2ca5e32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for reading YAF flows from an open file pointer.  <br /></td></tr>
<tr class="separator:ab16f93ae5f4e71b3a5928feb2ca5e32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aa6a5b106786904819cce86b0c736d" id="r_ae1aa6a5b106786904819cce86b0c736d"><td class="memItemLeft" align="right" valign="top">fbListener_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1aa6a5b106786904819cce86b0c736d">yfListenerForSpec</a> (fbConnSpec_t *spec, fbListenerAppInit_fn appinit, fbListenerAppFree_fn appfree, GError **err)</td></tr>
<tr class="memdesc:ae1aa6a5b106786904819cce86b0c736d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network.  <br /></td></tr>
<tr class="separator:ae1aa6a5b106786904819cce86b0c736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4916880e1835ed3bc8d2912791076caf" id="r_a4916880e1835ed3bc8d2912791076caf"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4916880e1835ed3bc8d2912791076caf">yfReadFlow</a> (fBuf_t *fbuf, <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a4916880e1835ed3bc8d2912791076caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single flow from an IPFIX message buffer.  <br /></td></tr>
<tr class="separator:a4916880e1835ed3bc8d2912791076caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2508ff2b0d463c2689e382e4b46bc167" id="r_a2508ff2b0d463c2689e382e4b46bc167"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2508ff2b0d463c2689e382e4b46bc167">yfReadFlowExtended</a> (fBuf_t *fbuf, <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a2508ff2b0d463c2689e382e4b46bc167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single flow from an IPFIX message buffer.  <br /></td></tr>
<tr class="separator:a2508ff2b0d463c2689e382e4b46bc167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65663f982cb1eec1717c9608584c2ff0" id="r_a65663f982cb1eec1717c9608584c2ff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65663f982cb1eec1717c9608584c2ff0">yfPrintString</a> (GString *rstr, <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow)</td></tr>
<tr class="memdesc:a65663f982cb1eec1717c9608584c2ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a GString.  <br /></td></tr>
<tr class="separator:a65663f982cb1eec1717c9608584c2ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7320f2e7a349df396c09ebfccbb9311a" id="r_a7320f2e7a349df396c09ebfccbb9311a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7320f2e7a349df396c09ebfccbb9311a">yfPrintDelimitedString</a> (GString *rstr, <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, gboolean yaft_mac)</td></tr>
<tr class="memdesc:a7320f2e7a349df396c09ebfccbb9311a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a GString in pipe-delimited (tabular) format.  <br /></td></tr>
<tr class="separator:a7320f2e7a349df396c09ebfccbb9311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84556dc608d472f7efa5c7a22a1ed714" id="r_a84556dc608d472f7efa5c7a22a1ed714"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84556dc608d472f7efa5c7a22a1ed714">yfPrint</a> (FILE *out, <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a84556dc608d472f7efa5c7a22a1ed714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a file.  <br /></td></tr>
<tr class="separator:a84556dc608d472f7efa5c7a22a1ed714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67f74d1debf3a8af50537cfa714fd2b" id="r_ac67f74d1debf3a8af50537cfa714fd2b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac67f74d1debf3a8af50537cfa714fd2b">yfPrintDelimited</a> (FILE *out, <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, gboolean yaft_mac, GError **err)</td></tr>
<tr class="memdesc:ac67f74d1debf3a8af50537cfa714fd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a file in pipe-delimited (tabular) format.  <br /></td></tr>
<tr class="separator:ac67f74d1debf3a8af50537cfa714fd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e6ac6049bf5feb7c9d4c2430a4ce1" id="r_ad77e6ac6049bf5feb7c9d4c2430a4ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad77e6ac6049bf5feb7c9d4c2430a4ce1">yfPrintColumnHeaders</a> (FILE *out, gboolean yaft_mac, GError **err)</td></tr>
<tr class="memdesc:ad77e6ac6049bf5feb7c9d4c2430a4ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print column headers for the pipe-delimited (tabular) format.  <br /></td></tr>
<tr class="separator:ad77e6ac6049bf5feb7c9d4c2430a4ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>YAF Core Library. </p>
<p>Defines API for reading and writing YAF files, and the yfFlow_t data structures. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a90bf8a39a94f6927eccf237b681308d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf8a39a94f6927eccf237b681308d7">&#9670;&#160;</a></span>YAF_ERROR_DOMAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_ERROR_DOMAIN&#160;&#160;&#160;(g_quark_from_string(&quot;certYAFError&quot;))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GError domain for YAF errors. </p>
<p>All YAF errors belong to this domain. In addition, YAF core library routines can return libfixbuf errors if reading or writing fails. </p>

</div>
</div>
<a id="aca5a2f530d778e1f7f1f4973a278a2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5a2f530d778e1f7f1f4973a278a2f6">&#9670;&#160;</a></span>YAF_ERROR_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_ERROR_HEADER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF file header was malformed. </p>
<p>The file is probably not a YAF file. </p>

</div>
</div>
<a id="a748ec2ae26f407ac851800cdd787a552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748ec2ae26f407ac851800cdd787a552">&#9670;&#160;</a></span>YAF_FLOW_ACTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_FLOW_ACTIVE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pseudo end reason for flows still active during collection. </p>
<p>Not valid on disk. </p>

</div>
</div>
<a id="a36347f7131aec21a8017ef32a61454c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36347f7131aec21a8017ef32a61454c6">&#9670;&#160;</a></span>YAF_LARGE_PKT_BOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_LARGE_PKT_BOUND&#160;&#160;&#160;225</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower bound of a packet's payload octets to be a "large packet" in the detailed flow-stats. </p>
<p>Payload octets must be greater than this value. </p>

</div>
</div>
<a id="ad935c8182e21f98f6ea867f09a2ffac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad935c8182e21f98f6ea867f09a2ffac1">&#9670;&#160;</a></span>YAF_SMALL_PKT_BOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_SMALL_PKT_BOUND&#160;&#160;&#160;60</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper bound of a packet's payload octets to be a "small packet" in the detailed flow-stats. </p>
<p>Payload octets must be less than this value. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac846c7e494485aceab2fcdec4264f90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac846c7e494485aceab2fcdec4264f90f">&#9670;&#160;</a></span>yfFlow_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structyf_flow__st.html">yfFlow_st</a> <a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF flow. </p>
<p>Joins a flow key with forward and reverse flow values in time.</p>
<dl class="section note"><dt>Note</dt><dd>if you edit the layout of this structure, you must make a corresponding edit of the yfFlowIPv4_t structure in yaftab.c </dd></dl>

</div>
</div>
<a id="a1ac4b4f6b2720c2af3c728aec9abd7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac4b4f6b2720c2af3c728aec9abd7a2">&#9670;&#160;</a></span>yfFlowKey_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structyf_flow_key__st.html">yfFlowKey_st</a> <a class="el" href="#a1ac4b4f6b2720c2af3c728aec9abd7a2">yfFlowKey_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF flow key. </p>
<p>Contains a flow's five-tuple; used at runtime in the flow table.</p>
<dl class="section note"><dt>Note</dt><dd>if you edit the layout of this structure, you must make a corresponding edit of the yfFlowKeyIPv4_t structure in yaftab.c </dd></dl>

</div>
</div>
<a id="a9c408b16b38eab11ab595368798ac304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c408b16b38eab11ab595368798ac304">&#9670;&#160;</a></span>yfFlowVal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structyf_flow_val__st.html">yfFlowVal_st</a> <a class="el" href="#a9c408b16b38eab11ab595368798ac304">yfFlowVal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF uniflow value. </p>
<p>Contains directional packet header fields and counters; two of these are used to build a biflow. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a68e5082889de2a82f6696c2b62842f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e5082889de2a82f6696c2b62842f07">&#9670;&#160;</a></span>yfRecordTimeIE_en</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a68e5082889de2a82f6696c2b62842f07">yfRecordTimeIE_en</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type to specify which timestamps are included. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a68e5082889de2a82f6696c2b62842f07aa645f9b1a6baa00352a39c7ddb4e98af"></a>YF_TIME_IE__UNSET&#160;</td><td class="fielddoc"><p>Unset value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a68e5082889de2a82f6696c2b62842f07aa5c8299e6b5f68ac36dcb280e2ec4402"></a>YF_TIME_IE_MILLI&#160;</td><td class="fielddoc"><p>Include flowStartMilliseconds, etc in the export template. </p>
</td></tr>
<tr><td class="fieldname"><a id="a68e5082889de2a82f6696c2b62842f07a68ed164cc0bb7d8a3d0b7aa1b6aae928"></a>YF_TIME_IE_MICRO&#160;</td><td class="fielddoc"><p>Include flowStartMicrioseconds, etc in the export template. </p>
</td></tr>
<tr><td class="fieldname"><a id="a68e5082889de2a82f6696c2b62842f07a3b3e785e296772ae50f44bc230ac0d4d"></a>YF_TIME_IE_NANO&#160;</td><td class="fielddoc"><p>Include flowStartNanoseconds, etc in the export template. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a68a8f1cdca0c20efb8bce1dd0e6917c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a8f1cdca0c20efb8bce1dd0e6917c1">&#9670;&#160;</a></span>yfAlignmentCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfAlignmentCheck </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>yfAlignmentCheck </p>
<p>This is a purely internal diagnostic function. It checks the alignment of the internal data structures that are used with fixbuf and causes the program to abort if there is an alignment issue. </p>

</div>
</div>
<a id="a771c185221c27f7b69374c40b208a0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771c185221c27f7b69374c40b208a0e3">&#9670;&#160;</a></span>yfFlowCleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfFlowCleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after a static flow buffer prepared by yfFlowPrepare. </p>
<p>This is used to free storage for payload information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flow</td><td>a yfFlow_t to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96a23294d877e529cacc564bb3a51488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a23294d877e529cacc564bb3a51488">&#9670;&#160;</a></span>yfFlowPrepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfFlowPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a static flow buffer for use with yaf_flow_read(). </p>
<p>Call this before the first yaf_flow_read() call; subsequent reads do not need initialization. This is used to prepare storage for payload information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flow</td><td>a yfFlow_t to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1aa6a5b106786904819cce86b0c736d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aa6a5b106786904819cce86b0c736d">&#9670;&#160;</a></span>yfListenerForSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fbListener_t * yfListenerForSpec </td>
          <td>(</td>
          <td class="paramtype">fbConnSpec_t *</td>          <td class="paramname"><span class="paramname"><em>spec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fbListenerAppInit_fn</td>          <td class="paramname"><span class="paramname"><em>appinit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fbListenerAppFree_fn</td>          <td class="paramname"><span class="paramname"><em>appfree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>fixbuf connection specifier for local end of socket. </td></tr>
    <tr><td class="paramname">appinit</td><td>Application context initialization function, for creating application-specific collector contexts. Pass NULL for no appinit function. </td></tr>
    <tr><td class="paramname">appfree</td><td>Application context cleanup function. Pass NULL for no appfree function. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new listener, initialized for reading YAF flows, for use with fbListenerWait(). Buffers returned from this call can then be used with <a class="el" href="#a4916880e1835ed3bc8d2912791076caf" title="Read a single flow from an IPFIX message buffer.">yfReadFlow()</a> and <a class="el" href="#a2508ff2b0d463c2689e382e4b46bc167" title="Read a single flow from an IPFIX message buffer.">yfReadFlowExtended()</a>. </dd></dl>

</div>
</div>
<a id="a84556dc608d472f7efa5c7a22a1ed714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84556dc608d472f7efa5c7a22a1ed714">&#9670;&#160;</a></span>yfPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfPrint </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>file to print to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
    <tr><td class="paramname">err</td><td>an error descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ad77e6ac6049bf5feb7c9d4c2430a4ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77e6ac6049bf5feb7c9d4c2430a4ce1">&#9670;&#160;</a></span>yfPrintColumnHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfPrintColumnHeaders </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean</td>          <td class="paramname"><span class="paramname"><em>yaft_mac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print column headers for the pipe-delimited (tabular) format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>file to print to. </td></tr>
    <tr><td class="paramname">yaft_mac</td><td>print mac address column headers if enabled </td></tr>
    <tr><td class="paramname">err</td><td>an error descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ac67f74d1debf3a8af50537cfa714fd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67f74d1debf3a8af50537cfa714fd2b">&#9670;&#160;</a></span>yfPrintDelimited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfPrintDelimited </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean</td>          <td class="paramname"><span class="paramname"><em>yaft_mac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a file in pipe-delimited (tabular) format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>file to print to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
    <tr><td class="paramname">yaft_mac</td><td>print mac addresses in tabular format </td></tr>
    <tr><td class="paramname">err</td><td>an error descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a7320f2e7a349df396c09ebfccbb9311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7320f2e7a349df396c09ebfccbb9311a">&#9670;&#160;</a></span>yfPrintDelimitedString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfPrintDelimitedString </td>
          <td>(</td>
          <td class="paramtype">GString *</td>          <td class="paramname"><span class="paramname"><em>rstr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean</td>          <td class="paramname"><span class="paramname"><em>yaft_mac</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a GString in pipe-delimited (tabular) format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rstr</td><td>string to append text representation of flow to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
    <tr><td class="paramname">yaft_mac</td><td>Add mac addresses to tabular format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65663f982cb1eec1717c9608584c2ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65663f982cb1eec1717c9608584c2ff0">&#9670;&#160;</a></span>yfPrintString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfPrintString </td>
          <td>(</td>
          <td class="paramtype">GString *</td>          <td class="paramname"><span class="paramname"><em>rstr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a GString. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rstr</td><td>string to append text representation of flow to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab16f93ae5f4e71b3a5928feb2ca5e32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16f93ae5f4e71b3a5928feb2ca5e32e">&#9670;&#160;</a></span>yfReaderForFP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfReaderForFP </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *</td>          <td class="paramname"><span class="paramname"><em>fbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for reading YAF flows from an open file pointer. </p>
<p>Reuses an existing buffer if supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>IPFIX message buffer to reuse; must have been returned by a prior call to <a class="el" href="#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a>. Pass NULL to create a new buffer. </td></tr>
    <tr><td class="paramname">fp</td><td>File pointer to open file to read from. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new reader, or a reused reader, for reading the given open file. NULL on failure. </dd></dl>

</div>
</div>
<a id="a4916880e1835ed3bc8d2912791076caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4916880e1835ed3bc8d2912791076caf">&#9670;&#160;</a></span>yfReadFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfReadFlow </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *</td>          <td class="paramname"><span class="paramname"><em>fbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single flow from an IPFIX message buffer. </p>
<p>The buffer must have been returned by <a class="el" href="#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a>, or by fbListenerWait() called on a listener created by <a class="el" href="#ae1aa6a5b106786904819cce86b0c736d" title="Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network.">yfListenerForSpec()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>Buffer to read message from, returned by <a class="el" href="#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a> or from a YAF listener. </td></tr>
    <tr><td class="paramname">flow</td><td>pointer to yfFlow_t structure to fill from file or stream. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. If false, check error against FB_ERROR_EOF to determine if the message reader is at end of file or stream, or against FB_ERROR_EOM to see if the listener should be waited upon. </dd></dl>

</div>
</div>
<a id="a2508ff2b0d463c2689e382e4b46bc167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2508ff2b0d463c2689e382e4b46bc167">&#9670;&#160;</a></span>yfReadFlowExtended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfReadFlowExtended </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *</td>          <td class="paramname"><span class="paramname"><em>fbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single flow from an IPFIX message buffer. </p>
<p>The buffer must have been returned by <a class="el" href="#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a>, or by fbListenerWait() called on a listener created by <a class="el" href="#ae1aa6a5b106786904819cce86b0c736d" title="Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network.">yfListenerForSpec()</a>. This function does not necessarily require its input to have been written by <a class="el" href="#a4aba445d9e6561395ee1a2de5a91ac15" title="Write a single flow to an IPFIX message buffer.">yfWriteFlow()</a>; it supports additional flow timestamp and counter IEs that may be exported by other IPFIX exporting processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>Buffer to read message from, returned by <a class="el" href="#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a> or from a YAF listener. </td></tr>
    <tr><td class="paramname">flow</td><td>pointer to yfFlow_t structure to fill from file or stream. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. If false, check error against FB_ERROR_EOF to determine if the message reader is at end of file or stream, or against FB_ERROR_EOM to see if the listener should be waited upon. </dd></dl>

</div>
</div>
<a id="a4aba445d9e6561395ee1a2de5a91ac15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aba445d9e6561395ee1a2de5a91ac15">&#9670;&#160;</a></span>yfWriteFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteFlow </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>yfContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *</td>          <td class="paramname"><span class="paramname"><em>flow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single flow to an IPFIX message buffer. </p>
<p>The buffer must have been returned by <a class="el" href="#a7bb316c0a5e8ea19331de902e7e7117c" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="#a07801f2dd9e1f54315b2f817e0eb3fd4" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer, a buffer to write the message to, returned from <a class="el" href="#a7bb316c0a5e8ea19331de902e7e7117c" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="#a07801f2dd9e1f54315b2f817e0eb3fd4" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a> </td></tr>
    <tr><td class="paramname">flow</td><td>pointer to yfFlow_t to write to file or stream. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a107643892b9846c39b27ecea4b90cf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107643892b9846c39b27ecea4b90cf35">&#9670;&#160;</a></span>yfWriteOptionsDataFlows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteOptionsDataFlows </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>yfContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>pcap_drop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GTimer *</td>          <td class="paramname"><span class="paramname"><em>timer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper that calls both yfWriteStatsFlow and yfWriteDataFlow with appropriate condition checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer. </td></tr>
    <tr><td class="paramname">pcap_drop</td><td>Number of packets dropped reported by libpcap </td></tr>
    <tr><td class="paramname">timer</td><td>Pointer to yafstats GTimer </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ace9d2497ad9dfacc3abb8cc20a95492b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9d2497ad9dfacc3abb8cc20a95492b">&#9670;&#160;</a></span>yfWriterClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriterClose </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *</td>          <td class="paramname"><span class="paramname"><em>fbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean</td>          <td class="paramname"><span class="paramname"><em>flush</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the connection underlying an IPFIX message buffer created by <a class="el" href="#a7bb316c0a5e8ea19331de902e7e7117c" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="#a07801f2dd9e1f54315b2f817e0eb3fd4" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a>. </p>
<p>If flush is TRUE, forces any message in progress to be emitted before close; use FALSE if closing the buffer in response to a write error. Does not free the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>buffer to close. </td></tr>
    <tr><td class="paramname">flush</td><td>TRUE to flush buffer before closing. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a73aba3cec2881f1779b63d0586cb1daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aba3cec2881f1779b63d0586cb1daf">&#9670;&#160;</a></span>yfWriterForFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfWriterForFile </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a30f599742a1993bfa79934307e0c26e1">yfConfig_t</a> *</td>          <td class="paramname"><span class="paramname"><em>yfConfig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for writing YAF flows to a named file. </p>
<p>Sets the observation domain of the buffer to the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Name of the file to write to, or - for stdout. </td></tr>
    <tr><td class="paramname">yfConfig</td><td>YAF configuration settings </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fBuf_t a new writer, or a reused writer, for writing on the given open file. NULL on failure. </dd></dl>

</div>
</div>
<a id="a7bb316c0a5e8ea19331de902e7e7117c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb316c0a5e8ea19331de902e7e7117c">&#9670;&#160;</a></span>yfWriterForFP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfWriterForFP </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a30f599742a1993bfa79934307e0c26e1">yfConfig_t</a> *</td>          <td class="paramname"><span class="paramname"><em>yfConfig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for writing YAF flows to an open file pointer. </p>
<p>Sets the observation domain of the buffer to the given value. Note that this is intended for use with Airframe MIO based applications; non-MIO applications writing YAF IPFIX files should use yfWriterForFile instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>File pointer to open file to write to. </td></tr>
    <tr><td class="paramname">yfConfig</td><td>YAF configuration settings </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fBuf_t a new writer, or a reused writer, for writing on the given open file. NULL on failure. </dd></dl>

</div>
</div>
<a id="a07801f2dd9e1f54315b2f817e0eb3fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07801f2dd9e1f54315b2f817e0eb3fd4">&#9670;&#160;</a></span>yfWriterForSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfWriterForSpec </td>
          <td>(</td>
          <td class="paramtype">fbConnSpec_t *</td>          <td class="paramname"><span class="paramname"><em>spec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a30f599742a1993bfa79934307e0c26e1">yfConfig_t</a> *</td>          <td class="paramname"><span class="paramname"><em>yfConfig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for writing YAF flows to a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>fixbuf connection specifier for remote end of socket. </td></tr>
    <tr><td class="paramname">yfConfig</td><td>YAF configuration settings </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new writer for export to the given address. </dd></dl>

</div>
</div>
<a id="aad688e7ab8e1c8a7c221db81b8b4ab9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad688e7ab8e1c8a7c221db81b8b4ab9b">&#9670;&#160;</a></span>yfWriteStatsFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteStatsFlow </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>yfContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>pcap_drop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GTimer *</td>          <td class="paramname"><span class="paramname"><em>timer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a statistics options data record to an IPFIX Message buffer. </p>
<p>To turn off stats output - use &ndash;nostats. Sets the internal template to the stats option template, builds the record, and sends it - then sets the internal template back to the full flow record.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer. </td></tr>
    <tr><td class="paramname">pcap_drop</td><td>Number of packets dropped reported by libpcap </td></tr>
    <tr><td class="paramname">timer</td><td>Pointer to yafstats GTimer </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a791a57ef2c8c5e66afa9ca3b9ceaa298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791a57ef2c8c5e66afa9ca3b9ceaa298">&#9670;&#160;</a></span>yfWriteTombstoneFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteTombstoneFlow </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>yfContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a tombstone options data record to an IPFIX Message buffer. </p>
<p>Sets the internal template to the tombstone option template, builds the record, and sends it - then sets the internal template back to the full flow record.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</body>
</html>

