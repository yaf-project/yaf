<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--
    Copyright (C) 2006-2025 Carnegie Mellon University
    See license information in LICENSE.txt.
-->
<!--
    @DISTRIBUTION_STATEMENT_BEGIN@
    YAF 2.16
    Copyright 2024 Carnegie Mellon University.
    NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
    INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
    UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
    AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR
    PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF
    THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF
    ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
    INFRINGEMENT.
    Licensed under a GNU GPL 2.0-style license, please see LICENSE.txt or
    contact permission@sei.cmu.edu for full terms.
    [DISTRIBUTION STATEMENT A] This material has been approved for public
    release and unlimited distribution.  Please see Copyright notice for
    non-US Government use and distribution.
    This Software includes and/or makes use of Third-Party Software each
    subject to its own license.
    DM24-1063
    @DISTRIBUTION_STATEMENT_END@
-->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAF: yfFlowTabConfig_st Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Tutorials</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">yfFlowTabConfig_st Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="yaftab_8h_source.html">yaftab.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ad156861c9b99076eafda2b6333a34afb" id="r_ad156861c9b99076eafda2b6333a34afb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad156861c9b99076eafda2b6333a34afb">active_sec</a></td></tr>
<tr class="memdesc:ad156861c9b99076eafda2b6333a34afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Active timeout in seconds.  <br /></td></tr>
<tr class="separator:ad156861c9b99076eafda2b6333a34afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06d3b024e09cb885683525eaaadbc8a" id="r_ac06d3b024e09cb885683525eaaadbc8a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac06d3b024e09cb885683525eaaadbc8a">idle_sec</a></td></tr>
<tr class="memdesc:ac06d3b024e09cb885683525eaaadbc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle timeout in seconds.  <br /></td></tr>
<tr class="separator:ac06d3b024e09cb885683525eaaadbc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab468712c654cf41e80043fbf38462297" id="r_ab468712c654cf41e80043fbf38462297"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab468712c654cf41e80043fbf38462297">max_flows</a></td></tr>
<tr class="memdesc:ab468712c654cf41e80043fbf38462297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of active flows.  <br /></td></tr>
<tr class="separator:ab468712c654cf41e80043fbf38462297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094df4e6e279c17b62be60c0874c4849" id="r_a094df4e6e279c17b62be60c0874c4849"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a094df4e6e279c17b62be60c0874c4849">max_payload</a></td></tr>
<tr class="memdesc:a094df4e6e279c17b62be60c0874c4849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum octets of payload to capture per flow direction.  <br /></td></tr>
<tr class="separator:a094df4e6e279c17b62be60c0874c4849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4044ccf38dc4724b9f1cfc14255b2db9" id="r_a4044ccf38dc4724b9f1cfc14255b2db9"><td class="memItemLeft" align="right" valign="top"><a id="a4044ccf38dc4724b9f1cfc14255b2db9"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ndpi_proto_file</b></td></tr>
<tr class="memdesc:a4044ccf38dc4724b9f1cfc14255b2db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If not NULL, and ndpi is TRUE, use the provided protocol file to expand the sub-protocols list and port-based detection methods. <br /></td></tr>
<tr class="separator:a4044ccf38dc4724b9f1cfc14255b2db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767332ce30359a128dbf87c76f46810d" id="r_a767332ce30359a128dbf87c76f46810d"><td class="memItemLeft" align="right" valign="top"><a id="a767332ce30359a128dbf87c76f46810d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>pcap_dir</b></td></tr>
<tr class="memdesc:a767332ce30359a128dbf87c76f46810d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directory to put pcap-per-flow files. <br /></td></tr>
<tr class="separator:a767332ce30359a128dbf87c76f46810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38951d3fa85f89bbf65b3ee850f87e6f" id="r_a38951d3fa85f89bbf65b3ee850f87e6f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38951d3fa85f89bbf65b3ee850f87e6f">pcap_meta_file</a></td></tr>
<tr class="memdesc:a38951d3fa85f89bbf65b3ee850f87e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">File for pcap meta output.  <br /></td></tr>
<tr class="separator:a38951d3fa85f89bbf65b3ee850f87e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f6ec1c8335bf8297955d639fd4873d" id="r_ad5f6ec1c8335bf8297955d639fd4873d"><td class="memItemLeft" align="right" valign="top"><a id="ad5f6ec1c8335bf8297955d639fd4873d"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pcap_max</b></td></tr>
<tr class="memdesc:ad5f6ec1c8335bf8297955d639fd4873d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size [in bytes] of a pcap file before rotating. <br /></td></tr>
<tr class="separator:ad5f6ec1c8335bf8297955d639fd4873d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd74923aa048e49728a9bec1caeb5738" id="r_acd74923aa048e49728a9bec1caeb5738"><td class="memItemLeft" align="right" valign="top"><a id="acd74923aa048e49728a9bec1caeb5738"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pcap_search_flowkey</b></td></tr>
<tr class="memdesc:acd74923aa048e49728a9bec1caeb5738"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flow key hash to create a PCAP for. <br /></td></tr>
<tr class="separator:acd74923aa048e49728a9bec1caeb5738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae1c14a6d5b68309ebf7e4612cebca9" id="r_afae1c14a6d5b68309ebf7e4612cebca9"><td class="memItemLeft" align="right" valign="top"><a id="afae1c14a6d5b68309ebf7e4612cebca9"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>pcap_search_stime</b></td></tr>
<tr class="memdesc:afae1c14a6d5b68309ebf7e4612cebca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The start time to create a PCAP for. <br /></td></tr>
<tr class="separator:afae1c14a6d5b68309ebf7e4612cebca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97265104ceef77308129ee1584f7275a" id="r_a97265104ceef77308129ee1584f7275a"><td class="memItemLeft" align="right" valign="top"><a id="a97265104ceef77308129ee1584f7275a"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>udp_uniflow_port</b></td></tr>
<tr class="memdesc:a97265104ceef77308129ee1584f7275a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If not 0, then this will enable exporting a single UDP packet with this src/dst port as a flow. <br /></td></tr>
<tr class="separator:a97265104ceef77308129ee1584f7275a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944d8266901dda3d6980b3f59e499478" id="r_a944d8266901dda3d6980b3f59e499478"><td class="memItemLeft" align="right" valign="top"><a id="a944d8266901dda3d6980b3f59e499478"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>applabel_mode</b></td></tr>
<tr class="memdesc:a944d8266901dda3d6980b3f59e499478"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then the payload, (as limited by max_payload,) is sent through various plugins and code in order to determine which protocol is running on the flow by doing only payload inspection and exporting payload relevent information. <br /></td></tr>
<tr class="separator:a944d8266901dda3d6980b3f59e499478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349c9147dbaf88b66a7bcc907453ed25" id="r_a349c9147dbaf88b66a7bcc907453ed25"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a349c9147dbaf88b66a7bcc907453ed25">entropy_mode</a></td></tr>
<tr class="memdesc:a349c9147dbaf88b66a7bcc907453ed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then a Shannon Entropy measurement is made over the captured payload (as limited by max_payload).  <br /></td></tr>
<tr class="separator:a349c9147dbaf88b66a7bcc907453ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b7c6ec72c90d7cb63bace2e6548cc6" id="r_a07b7c6ec72c90d7cb63bace2e6548cc6"><td class="memItemLeft" align="right" valign="top"><a id="a07b7c6ec72c90d7cb63bace2e6548cc6"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>flowstats_mode</b></td></tr>
<tr class="memdesc:a07b7c6ec72c90d7cb63bace2e6548cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then YAF will do some extra calculations on flows. <br /></td></tr>
<tr class="separator:a07b7c6ec72c90d7cb63bace2e6548cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c539a720cf18586f7d9962d179320e" id="r_af5c539a720cf18586f7d9962d179320e"><td class="memItemLeft" align="right" valign="top"><a id="af5c539a720cf18586f7d9962d179320e"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>force_read_all</b></td></tr>
<tr class="memdesc:af5c539a720cf18586f7d9962d179320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then yaf will process files that are out of sequence. <br /></td></tr>
<tr class="separator:af5c539a720cf18586f7d9962d179320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594ad5ca29ca29ae461875198fb7f03c" id="r_a594ad5ca29ca29ae461875198fb7f03c"><td class="memItemLeft" align="right" valign="top"><a id="a594ad5ca29ca29ae461875198fb7f03c"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>fpexport_mode</b></td></tr>
<tr class="memdesc:a594ad5ca29ca29ae461875198fb7f03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then this will enable exporting of full packet banners of the TCP negotiations for the first three packets (including IP and transport headers) for external fingerprinting. <br /></td></tr>
<tr class="separator:a594ad5ca29ca29ae461875198fb7f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69ad4a93954c51e5454f7bb06957403" id="r_ab69ad4a93954c51e5454f7bb06957403"><td class="memItemLeft" align="right" valign="top"><a id="ab69ad4a93954c51e5454f7bb06957403"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>mac_mode</b></td></tr>
<tr class="memdesc:ab69ad4a93954c51e5454f7bb06957403"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, collect and export source and destination Mac Addresses. <br /></td></tr>
<tr class="separator:ab69ad4a93954c51e5454f7bb06957403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4757f2da5d954cc5df73fc11e7bdbb" id="r_a3a4757f2da5d954cc5df73fc11e7bdbb"><td class="memItemLeft" align="right" valign="top"><a id="a3a4757f2da5d954cc5df73fc11e7bdbb"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>ndpi</b></td></tr>
<tr class="memdesc:a3a4757f2da5d954cc5df73fc11e7bdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, enable nDPI application labeling with standard protocols. <br /></td></tr>
<tr class="separator:a3a4757f2da5d954cc5df73fc11e7bdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9146fa216ea046ccb62f45ec8abbf31f" id="r_a9146fa216ea046ccb62f45ec8abbf31f"><td class="memItemLeft" align="right" valign="top"><a id="a9146fa216ea046ccb62f45ec8abbf31f"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>no_vlan_in_key</b></td></tr>
<tr class="memdesc:a9146fa216ea046ccb62f45ec8abbf31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, this will remove the vlan in the calculation of the flow key hash. <br /></td></tr>
<tr class="separator:a9146fa216ea046ccb62f45ec8abbf31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493c784fea3c0651fbb03598bba56e1" id="r_a4493c784fea3c0651fbb03598bba56e1"><td class="memItemLeft" align="right" valign="top"><a id="a4493c784fea3c0651fbb03598bba56e1"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>p0f_mode</b></td></tr>
<tr class="memdesc:a4493c784fea3c0651fbb03598bba56e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then this will enable passive OS finger printing using the p0f engine based mostly on TCP negotiation. <br /></td></tr>
<tr class="separator:a4493c784fea3c0651fbb03598bba56e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045f6e42a2f2cf3f9941121ca7880926" id="r_a045f6e42a2f2cf3f9941121ca7880926"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a045f6e42a2f2cf3f9941121ca7880926">pcap_index</a></td></tr>
<tr class="memdesc:a045f6e42a2f2cf3f9941121ca7880926"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, print one line per packet we export.  <br /></td></tr>
<tr class="separator:a045f6e42a2f2cf3f9941121ca7880926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdf2f575a1e93d0e2f15f0ea2b97245" id="r_a9fdf2f575a1e93d0e2f15f0ea2b97245"><td class="memItemLeft" align="right" valign="top"><a id="a9fdf2f575a1e93d0e2f15f0ea2b97245"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>pcap_per_flow</b></td></tr>
<tr class="memdesc:a9fdf2f575a1e93d0e2f15f0ea2b97245"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then pcap_dir will be set to the directory to place pcap-per-flow files. <br /></td></tr>
<tr class="separator:a9fdf2f575a1e93d0e2f15f0ea2b97245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6e3121739984b14dae114215013764" id="r_a0d6e3121739984b14dae114215013764"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d6e3121739984b14dae114215013764">silk_mode</a></td></tr>
<tr class="memdesc:a0d6e3121739984b14dae114215013764"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, clamp totalOctetCount and maxTotalOctetCount to 32 bits and force active timeout on overflow.  <br /></td></tr>
<tr class="separator:a0d6e3121739984b14dae114215013764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d6593248516b3e8a31ef48f13496a3" id="r_ae7d6593248516b3e8a31ef48f13496a3"><td class="memItemLeft" align="right" valign="top"><a id="ae7d6593248516b3e8a31ef48f13496a3"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>udp_multipkt_payload</b></td></tr>
<tr class="memdesc:ae7d6593248516b3e8a31ef48f13496a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, then this will enable capturing payload for all UDP packets in a flow (instead of just the first packet) up to <code>max_payload value</code>. <br /></td></tr>
<tr class="separator:ae7d6593248516b3e8a31ef48f13496a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74307570f8fb4822ba5d6eccda9af6a8" id="r_a74307570f8fb4822ba5d6eccda9af6a8"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74307570f8fb4822ba5d6eccda9af6a8">uniflow_mode</a></td></tr>
<tr class="memdesc:a74307570f8fb4822ba5d6eccda9af6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If TRUE, export biflows using record adjacency (two uniflows exported back-to-back.  <br /></td></tr>
<tr class="separator:a74307570f8fb4822ba5d6eccda9af6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Configuration settings used to initalize the flow table in <a class="el" href="yaftab_8h.html#afae5502658379fefb54de17d9a8389dd" title="yfFlowTabAlloc">yfFlowTabAlloc()</a>. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="ad156861c9b99076eafda2b6333a34afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad156861c9b99076eafda2b6333a34afb">&#9670;&#160;</a></span>active_sec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t yfFlowTabConfig_st::active_sec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Active timeout in seconds. </p>
<p>The maximum duration of a flow is the active timeout; additional packets for the same flow will be counted as part of a new flow. </p>

</div>
</div>
<a id="a349c9147dbaf88b66a7bcc907453ed25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349c9147dbaf88b66a7bcc907453ed25">&#9670;&#160;</a></span>entropy_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfFlowTabConfig_st::entropy_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If TRUE, then a Shannon Entropy measurement is made over the captured payload (as limited by max_payload). </p>
<p>The entropy value is exported as two values one for forward payload and one for reverse payload. </p>

</div>
</div>
<a id="ac06d3b024e09cb885683525eaaadbc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06d3b024e09cb885683525eaaadbc8a">&#9670;&#160;</a></span>idle_sec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t yfFlowTabConfig_st::idle_sec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idle timeout in seconds. </p>
<p>A flow that receives no packets for the idle timeout is assumed to be complete. </p>

</div>
</div>
<a id="ab468712c654cf41e80043fbf38462297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab468712c654cf41e80043fbf38462297">&#9670;&#160;</a></span>max_flows</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t yfFlowTabConfig_st::max_flows</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of active flows. </p>
<p>Flows exceeding this limit will be expired in least-recent order, as if they were idle. Used to limit resource usage of a flow table. A value of 0 disables flow count limits. </p>

</div>
</div>
<a id="a094df4e6e279c17b62be60c0874c4849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094df4e6e279c17b62be60c0874c4849">&#9670;&#160;</a></span>max_payload</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t yfFlowTabConfig_st::max_payload</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum octets of payload to capture per flow direction. </p>
<p>Requires at least max_payload octets of payload to be available in each packet buffer passed to <a class="el" href="yaftab_8h.html#ab37f151a4c4f8428eaf11655ec54be64" title="Add a decoded packet buffer to a given flow table.">yfFlowPBuf()</a>. A value of 0 disables payload capture and export. </p>

</div>
</div>
<a id="a045f6e42a2f2cf3f9941121ca7880926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045f6e42a2f2cf3f9941121ca7880926">&#9670;&#160;</a></span>pcap_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfFlowTabConfig_st::pcap_index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If TRUE, print one line per packet we export. </p>
<p>This will give offset and length into the pcap yaf writes. </p>

</div>
</div>
<a id="a38951d3fa85f89bbf65b3ee850f87e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38951d3fa85f89bbf65b3ee850f87e6f">&#9670;&#160;</a></span>pcap_meta_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* yfFlowTabConfig_st::pcap_meta_file</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File for pcap meta output. </p>
<p>Default is stdout </p>

</div>
</div>
<a id="a0d6e3121739984b14dae114215013764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6e3121739984b14dae114215013764">&#9670;&#160;</a></span>silk_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfFlowTabConfig_st::silk_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If TRUE, clamp totalOctetCount and maxTotalOctetCount to 32 bits and force active timeout on overflow. </p>
<p>Set high order bit in flowEndReason for each flow created on an overflow or active timeout. Breaks IPFIX interoperability; use for direct export to SiLK rwflowpack or flowcap. </p>

</div>
</div>
<a id="a74307570f8fb4822ba5d6eccda9af6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74307570f8fb4822ba5d6eccda9af6a8">&#9670;&#160;</a></span>uniflow_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfFlowTabConfig_st::uniflow_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If TRUE, export biflows using record adjacency (two uniflows exported back-to-back. </p>
<p>Use this for interoperability with IPFIX collectors that do not implement RFC 5103. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="yaftab_8h_source.html">yaftab.h</a></li>
</ul>
</div><!-- contents -->
</body>
</html>

